From: Scott Cantor <scantor@apache.org>
Date: Thu, 11 Oct 2018 15:13:40 +0000
Subject: SANTUARIO-496 - DSA verification crashes OpenSSL on invalid
 combinations of key content

Backport of
git-svn-id: https://svn.apache.org/repos/asf/santuario/xml-security-cpp/trunk@1843562 13f79535-47bb-0310-9956-ffa450edef68
---
 xsec/enc/OpenSSL/OpenSSLCryptoKeyDSA.cpp | 12 ++++++++++++
 xsec/enc/OpenSSL/OpenSSLCryptoKeyEC.cpp  | 12 ++++++++++++
 xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.cpp | 12 ++++++++++++
 3 files changed, 36 insertions(+)

diff --git a/xsec/enc/OpenSSL/OpenSSLCryptoKeyDSA.cpp b/xsec/enc/OpenSSL/OpenSSLCryptoKeyDSA.cpp
index 57999a2..5bdf133 100644
--- a/xsec/enc/OpenSSL/OpenSSLCryptoKeyDSA.cpp
+++ b/xsec/enc/OpenSSL/OpenSSLCryptoKeyDSA.cpp
@@ -164,6 +164,12 @@ bool OpenSSLCryptoKeyDSA::verifyBase64Signature(unsigned char * hashBuf,
 			"OpenSSL:DSA - Attempt to validate signature with empty key");
 	}
 
+    XSECCryptoKey::KeyType keyType = getKeyType();
+    if (keyType != KEY_DSA_PAIR && keyType != KEY_DSA_PUBLIC) {
+        throw XSECCryptoException(XSECCryptoException::DSAError,
+            "OpenSSL:DSA - Attempt to validate signature without public key");
+    }
+
     char* cleanedBase64Signature;
 	unsigned int cleanedBase64SignatureLen = 0;
 
@@ -264,6 +270,12 @@ unsigned int OpenSSLCryptoKeyDSA::signBase64Signature(unsigned char * hashBuf,
 			"OpenSSL:DSA - Attempt to sign data with empty key");
 	}
 
+    KeyType keyType = getKeyType();
+    if (keyType != KEY_DSA_PAIR && keyType != KEY_DSA_PRIVATE) {
+        throw XSECCryptoException(XSECCryptoException::DSAError,
+            "OpenSSL:DSA - Attempt to sign data without private key");
+    }
+
 	DSA_SIG * dsa_sig;
 
 	dsa_sig = DSA_do_sign(hashBuf, hashLen, mp_dsaKey);
diff --git a/xsec/enc/OpenSSL/OpenSSLCryptoKeyEC.cpp b/xsec/enc/OpenSSL/OpenSSLCryptoKeyEC.cpp
index 3233343..09ba69e 100644
--- a/xsec/enc/OpenSSL/OpenSSLCryptoKeyEC.cpp
+++ b/xsec/enc/OpenSSL/OpenSSLCryptoKeyEC.cpp
@@ -151,6 +151,12 @@ bool OpenSSLCryptoKeyEC::verifyBase64SignatureDSA(unsigned char * hashBuf,
 			"OpenSSL:EC - Attempt to validate signature with empty key");
 	}
 
+    KeyType keyType = getKeyType();
+    if (keyType != KEY_EC_PAIR && keyType != KEY_EC_PUBLIC) {
+        throw XSECCryptoException(XSECCryptoException::ECError,
+            "OpenSSL:EC - Attempt to validate signature without public key");
+    }
+
 	char * cleanedBase64Signature;
 	unsigned int cleanedBase64SignatureLen = 0;
 
@@ -225,6 +231,12 @@ unsigned int OpenSSLCryptoKeyEC::signBase64SignatureDSA(unsigned char * hashBuf,
 			"OpenSSL:EC - Attempt to sign data with empty key");
 	}
 
+    KeyType keyType = getKeyType();
+    if (keyType != KEY_EC_PAIR && keyType != KEY_EC_PRIVATE) {
+        throw XSECCryptoException(XSECCryptoException::ECError,
+            "OpenSSL:EC - Attempt to sign data without private key");
+    }
+
 	ECDSA_SIG * dsa_sig;
 
 	dsa_sig = ECDSA_do_sign(hashBuf, hashLen, mp_ecKey);
diff --git a/xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.cpp b/xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.cpp
index e21b001..c0d7b2b 100644
--- a/xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.cpp
+++ b/xsec/enc/OpenSSL/OpenSSLCryptoKeyRSA.cpp
@@ -416,6 +416,12 @@ bool OpenSSLCryptoKeyRSA::verifySHA1PKCS1Base64Signature(const unsigned char * h
 			"OpenSSL:RSA - Attempt to validate signature with empty key");
 	}
 
+    XSECCryptoKey::KeyType keyType = getKeyType();
+    if (keyType != KEY_RSA_PAIR && keyType != KEY_RSA_PUBLIC) {
+        throw XSECCryptoException(XSECCryptoException::RSAError,
+            "OpenSSL:RSA - Attempt to validate signature without public key");
+    }
+
 	char* cleanedBase64Signature;
 	unsigned int cleanedBase64SignatureLen = 0;
 
@@ -534,6 +540,12 @@ unsigned int OpenSSLCryptoKeyRSA::signSHA1PKCS1Base64Signature(unsigned char * h
 			"OpenSSL:RSA - Attempt to sign data with empty key");
 	}
 
+    KeyType keyType = getKeyType();
+    if (keyType != KEY_RSA_PAIR && keyType != KEY_RSA_PRIVATE) {
+        throw XSECCryptoException(XSECCryptoException::RSAError,
+            "OpenSSL:RSA - Attempt to sign data without private key");
+    }
+
 	// Build the buffer to be encrypted by prepending the SHA1 OID to the hash
 
 	unsigned char * encryptBuf;
